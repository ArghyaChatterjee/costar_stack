#ifndef SYMMETRIC_ORIENTATION_REALIGNMENT_H
#define SYMMETRIC_ORIENTATION_REALIGNMENT_H

#include <math.h>
#include <Eigen/Geometry>
#include <boost/math/constants/constants.hpp>

const double pi = boost::math::constants::pi<double>();

//for normalizing object rotation
struct ObjectSymmetry
{
    double roll;
    double pitch;
    double yaw;

    // for setting preferred axis
    std::string preferred_axis;
    double preferred_step;

    // NOTE: input is in degrees
    template <typename numericStandard>
    ObjectSymmetry(const numericStandard &input_roll, const numericStandard &input_pitch, const numericStandard &input_yaw)
        : roll(input_roll), pitch(input_pitch), yaw(input_yaw),
          preferred_axis(""),
          preferred_step(0.0) {}

    // NOTE: input is in degrees
    template <typename numericStandard>
    ObjectSymmetry(const numericStandard &input_roll, const numericStandard &input_pitch, const numericStandard &input_yaw,
        const std::string &axis, const numericStandard& step)
        : roll(input_roll), pitch(input_pitch), yaw(input_yaw),
          preferred_axis(axis),
          preferred_step(step) {}

    ObjectSymmetry() : roll(2*pi), pitch(2*pi), yaw(2*pi), preferred_axis("z"), preferred_step(0.) {}

    bool operator==(const ObjectSymmetry& other)
    {
        return (this->preferred_axis == other.preferred_axis) &&
        std::abs(this->roll - other.roll) < 0.00001 &&
        std::abs(this->pitch - other.pitch) < 0.00001 && 
        std::abs(this->yaw - other.yaw) < 0.00001 &&
        std::abs(this->preferred_step - other.preferred_step) < 0.00001;
    }

    bool operator!=(const ObjectSymmetry& other)
    {
        return !(*this == other);
    }
};

template <typename numericStandard>
void realignOrientation (Eigen::Matrix<numericStandard, 3, 3> &rot_matrix, const ObjectSymmetry &object, 
    const int axis_to_align, const bool with_rotate_specific_axis = false, const int rotate_around_specific_axis = 0);

template <typename numericStandard>
Eigen::Matrix<numericStandard, 3, 1> extractRPYfromRotMatrix(const Eigen::Matrix<numericStandard, 3, 3> &input,
    bool reverse_pitch = false);

// Compute the best matching orientation for an object with multiple symmetries.
// This implementation works by computing quaternion angular distance between
// identity and all candidate orientations, generated by rotating around the 
// each axis with a step specified in the ObjectSymmetry struct.
// For example:
// A cube might have 90 degree steps around x, y, and z.
template <typename numericStandard>
Eigen::Quaternion<numericStandard> normalizeModelOrientation(const Eigen::Quaternion<numericStandard> &q_from_pose,
    const ObjectSymmetry &object);

template <typename numericStandard>
void printQuaternion(const Eigen::Quaternion<numericStandard> &input);

template <typename numericStandard>
Eigen::Quaternion<numericStandard> normalizeModelOrientation(const Eigen::Quaternion<numericStandard> &q_new, 
    const Eigen::Quaternion<numericStandard>  &q_previous, const ObjectSymmetry &object);

#include "symmetric_orientation_realignment.tcc"

#endif